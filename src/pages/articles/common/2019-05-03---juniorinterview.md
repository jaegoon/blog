---
title: 신입 개발자 면접 질문 및 답변
date: "2019-05-03"
layout: post
draft: false
path: "/posts/interview"
category: "common"
tags:
  - "junior interview"
description: "객체지향에 대해서 설명해보라..."
---

신입 개발자가 면접시 질문 받을 만한 소프트웨어 전반에 걸쳐 기초적인 질문과 답변을 정리해보고자 한다.

## 1. 정렬 (sort)
1. 단순 구현 정렬 3가지


2. Shell sort


## 2. 객체지향

1. 객체지향 4대 특성에 대해 설명해보라.  
   - 추상화  (Abstraction)  
   표현하고자 하는 사물의 특성을 목적에 맞게 골라서 모델링하는 것. 자바에서는 클래스가 대표적인 추상화이다.
   - 상속성  (Inheritance)  
   상위 클래스의 특성을 하위 클래스에서 재사용 및 확장해 사용할 수 있다는 의미이다.
   '하위클래스 is a kind of 상위클래스' 문구에 의미가 맞아야 한다.
   - 다형성 (Polymorphism)  
   대표적으로 오버로딩과 오버라이딩을 나타낸다.
   오버로딩은 동일 메소드명에 다른 인자를 가진 메소드를 다양하게 사용할 수 있다는 의미이고, 오버라이딩은 상위 클래스의 메소드를 하위 클래스에서 같은 메소드명, 같은 인자를 가진 메소드로서 확장해 사용할 수 있다는 의미이다.
   - 은닉성 (Encapsulation)  
   접근제어자를 통해 필드 접근을 제어한다. private -> default -> protected -> public 순서로 접근을 많이 허용한다.  
   private : 동일 클래스만  
   default : 동일 패키지만  
   protected : 동일 패키지 및 상속받은 클래스만  
   public : 아무나


3. SOLID 객체지향 설계 5대 원칙에 대해 설명해보라.



## 3. Java

1. String, stringbuffer, stringBuilder 차이  
모두 문자열을 다루는 클래스이다. 이 둘의 차이는 String 클래스는 immutable 클래스이고 StringBuilder와 StringBuffer 클래스는 mutable 클래스라는 점이다. 그 의미에 대해서는 아래와 같다.
   1. String  
   `String str = new String("ABC");` 또는  `String str = "ABC";` 로 인스턴스가 최초에 생성된 후 '+' 또는 'concat'을 통한 문자열 연산시, 기존 문자열에 추가 문자열을 붙이는 것이 아니라 새로운 인스턴스를 만든다. (기존에 참조하던 데이터는 GC에 의해 나중에 삭제된다.) 따라서 문자열 연산이 많은 상황에서 이 클래스를 사용하면 속도가 느리고 리소스가 많이 든다. 다만 객체가 한번 만들어지면 변하지 않는 불변 속성으로 인해 조회시 더 빠른 속도를 가지며 불변이므로 동기화에 대해 safe한 특징을 가지고 있다.
   2. StringBuilder와 StringBuffer  
   이 두 클래스는 String 클래스와 다르게 기존 문자열에 추가로 문자열을 연산할 경우, 기존 문자열에 붙여서 연산을 진행한다. 따라서 연산속도가 훨씬 더 빠르다. 단, 이 두 클래스의 차이는 동기화 기능 여부다. StringBuffer는 Synchronized 기능을 가지고 있어 멀티스레드 환경에 safe하다. (thread-safe) 반대로 StringBuilder의 경우 thread-safe 하지 않은 대신 속도가 조금 더 빠르다는 특징을 가지고 있다.

2. 추상클래스와 인터페이스 차이  
선언만 있고 구현이 없는 클래스, 객체를 생성할 수 없다는 점이 둘의 공통점이다. 이 둘의 차이점은 목적에 있다. 인터페이스는 메소드 구현을 강제하는 것에 목적이 있고, 추상클래스는 메소드의 공유 및 확장에 그 목적이 있다. 좀 더 자세히 살펴보자.
   1. 추상클래스  
  abstract method가 있거나, abstract 키워드로 정의된 클래스로서 다중상속이 불가능하고 일반 변수 사용가능하다. 사용 목적은 말그대로 객체를 추상화할 때 사용된다. 'is a 관계'를 만족시킬 때 주로 사용된다. Tiger is a animal. Monkey is a animal. 등등, 여러 객체들을 나타내기 위해 추상되는 객체를 표현할 때 사용되나.
  2. 인터페이스  
  다중상속 가능, 상수만 사용할 수 있고 추상메소드만 있는 클래스이다.즉 모든 필드는 public static final이어야 하고 모든 메소드는 public abstract이어야 한다. 추상클래스와 마찬가지로 'is a 관계'를 만족하지만 목적이 조금 다르다. 'has a 기능'을 만족시킬 때 주로 사용된다. 즉 여러 객체에서 사용될 공통된 기능을 만들 때 사용한다. pencil 클래스와 colorPen 클래스가 모두 writing 기능을 사용한다면 공통으로 writing 인터페이스를 만들어 구현해 사용하는 것이 코드의 재사용 및 수정 면에서 훨씬 효율적이라는 것을 알 수 있다.

3. 메모리 영역의 이해  
자바의 메모리 영역은 크게, Static(Class 또는 Method 영역이라고도 한다), stack, heap 영역으로 나눌 수 있다.
   - static 영역 : 클래스 영역
   자바를 처음 구동하면 JRE가 main 메소드를 찾고, main 메소드가 확인되면 JVM을 구동시킨다. 구동된 JVM은 가장 먼저 목적파일들을 실행시킨다.  이후 java.lang 패키지와 모든 클래스, 임포트한 패키지들을 static 영역에 올린다. 이를 전처리 과정이라고 한다. static 영역에 자리 잡은 멤버들은 jvm 종료까지 존재하게 된다.
   - stack 영역 : 메소드 영역
   메소드가 실행되면 메소드가 시작되는 대괄호 `{` 부터 끝나는 `}`까지를 스택 프레임이라고 부르며 이 안에서 선언된 변수들을 지역변수라고 부른다. 모든 메소드들은 여기서 변수를 정의하고 실행된다.
   - heap 영역 : 객체(인스턴스) 영역
   new 키워드로 생성되는 모든 인스턴스들은 이 곳에 저장된다. 그리고 Garbage Collector가 작동할 때까지 소멸되지 않는다.

   ** 멀티스레드와 멀티프로세스의 차이  
   멀티스레드는 하나의 T메모리 영역에서 static과 heap영역은 공유하고 stack 영역만 스레드 개수만큼 분할해서 사용하는 것이고, 멀티프로세스는 T메모리 영역 자체를 구분해 사용한다. 따라서 static 영역에 선언되는 전역 변수는 thread - safe 하지 않다고 하는 것이다.

4. JVM 동작 원리




## 4. 개발 전반 

1. 라이브러리와 프레임워크의 차이는?   
개발 주도성을 개발자가 갖느냐의 차이이다. 프레임워크는 프레임워크의 코드 안에서 필요한 부분에 개발자의 코드가 들어간다. 즉 프레임워크가 개발 주도성을 가진다. 반대로 라이브러리는 개발자의 코드 안에서 필요한 부분에 라이브러리를 사용한다. 즉 개발자가 개발 주도성을 가진다.


2. Spring 삼각형  
   1. IoC (Inversion of Control) : 제어의 역전  / DI (Dependency Injection) : 의존주입  
   스프링에서는 객체의 생명 주기 관리를 개발자가 아닌 프레임워크의 컨테이너로 하기 때문에 객체에 대한 주도권이 개발자가 아닌 프레임워크에 있다는 것을 의미한다. 이를 통해 DI가 가능하다. DI 란, A 객체에서 B객체를 사용할 때, A객체에서 B 객체를 만들어 사용하는 것이 아니라, 다른 곳에서 만들어진 B객체를 주입 받아 사용하는 방식을 뜻한다.

   2. AOP (Aspected Oriented Programming) : 관점 지향 프로그래밍  
   핵심 비즈니스 어플리케이션을 제외한 부가적인 기능이 핵심 기능과 결합도가 높으면 소스 관리 및 개발이 어려워지므로 이를 해결하기 위해 사용되는 프로그래밍. 즉 핵심 기능들이 공통적으로 사용하는 기능들을 묶어서 별도로 관리한다. 부가 공통 기능으로는 로그인, 트랜잭션, 보안, 캐싱 등이 있다.

   3. PSA (Portable Service Abstractions)  
   환경의 변화에 관계없이 일관된 방식으로 기술 접근 환경을 제공하려는 추상화 구조를 뜻한다. 외부 라이브러리를 사용할 때 어떤 라이브러리인지에 관계없이 비슷한 종류의 라이브러리라면 같은 방식으로 사용하고 구동되도록 설계되어 있다. 대표적인 예시로 JDBC나, 스프링 JPA 등이 있다.

3. DB 정규화 (Normalization)  
CUD시, 데이터 이상(anormal)을 제거하는 것이 목적이다.
   1. 제1 정규화 : 1 행당 1 열은 1개의 값(Atomic value)를 갖는다.
   2. 제2 정규화 : 기본키가 아닌 컬럼은 기본키에 완전 함수 종속이어야 한다.(기본키의 일부에 종속적이면 안된다. -> 부분 함수 종속을 제거해야 한다.)
   3. 제3 정규화 : 기본키가 아닌 모든 컬럼들은 기본키에 이행 함수 종속이 아니어야 한다. (이행적 함수 종속 제거)
   이행적 함수 종속 개념이 조금 헤깔릴 수 있으니 예를 들어 보겠다. 주민등록번호를 PK로 하고, 이름, 직장명, 직장번호를 컬럼으로 가지는 테이블이 있을때, 직정번호는 직장명에 종속되며 이는 곧 직장번호와 주민등록번호가 이행적 함수 종속이라는 것이다.
   4. BCNF (Boyce-Codd Normal Form) : 후보키가 아니면서 결정자 컬럼이 있으면 분리해야 한다. (모든 결정자가 key인 경우 BCNF를 만족한다.) '학생, 과목명, 교수' 데이터가 있는 테이블에서 {학생, 과목명}을 PK로 설정할 경우 BCNF를 위반한다.
   ** 후보키는 기본키로 사용될 수 있는, '유일성', '최소성'을 만족하는 속성을 의미.



## 5. 네트워크

1. OSI 7 layer  
- 쉽게 외우는 방법 (뒤부터)   
Please Do Not Throw Sausage Pizza Away.
물리 데이터링크 네트워크 트랜스포트 세션 프레젠테이션 어플리케이션
-  


2. TCP/IP 5계층  
Application 층 - Transport 층 - Network 층 - DataLink 층 - Physical 층

   1. Application 층  
   사용자들이 이용할 수 있도록 통신 서비스를 만드는 층이다. 사용자들이 통신하기 위해서는 규약이 필요하고 대표적으로 HTTP 프로토콜이 있다. 목적지를 찾기 위해 포트를 이용한다.  

   2. Transport 층  
   어플리케이션 층의 데이터를 네트워크 층으로 중계하는 과정에서 통신되는 데이터에 문제 발생 여부를 확인한다. 이 층에서 사용하는 데이터 단위를 세그먼트라고 한다.
      1. TCP (Transmission Control Protocol)  
      수신측과 1:1로 통신한다. (아래 HandShake를 통해 통신) 확인 응답 없거나 데이터 파손(checksum) 등이 생기면 조치한다.
      2. UDP (User Datagram Protocol)  
      일방적으로 데이터를 보낼 때 사용한다. (스트리밍 서비스 같은) 여러 상대에게 동시에 보내는 멀티캐스트나 브로드캐스트가 가능하다. 단 checksum을 통해 데이터 파손 여부는 확인하되 그 외 어떤 응답도 확인하지 않는다.  

   3. Network 층  
   어떤 상대와 통신하느냐에 있어서 가장 중요한 계층이다. 인터넷 상에서 주소로 여겨지는 IP가 이곳의 핵심 프로토콜이다. IP는 비연결형 프로토콜이기 때문에 이를 돕기 위해 ICMP가 있다. 수신측에서 받은 데이터에 문제가 있다면 송신측에 메시지를 보내는 역할을 한다.

   4. DataLink 층  
   물리계층에서 받은 데이터를 네트워크 계층의 기기로 전송하는 역할을 한다. 식별자로 MAC 주소를 사용한다.
   ** IP주소와 MAC 주소의 차이
   MAC 주소는 하드웨어의 시리얼 번호처럼 완전 고유한 값이다. 하지만 IP의 경우, 상대적으로 고유한 값이다. IP는 공인 IP와 사설 IP로 나뉜다. 공인 IP는 집의 현관문 같은 존재다. 네트워크상에서 공인IP를 통해 현관문을 찾고, 현관문에 있는 공유기를 통해 기기 마다 새로운 사설 IP를 제공받는다. 따라서 이 사설 IP는 다른 IP들과 중복될 수 있다. (외부에서는 공인IP만 보이기 때문에 문제X) 따라서 완전 고유한 값은 아니다.

   5. Physical 층  
   데이터를 신호로, 신호를 데이터로 변환하는 계층이다.



3. HandShake  
  TCP 통신에서 통신상태를 전달하는 수단으로 TCP 헤더 있는 6비트짜리 컨트롤 플래그를 사용한다. 컨트롤 플래그는 다음과 같이 구성된다.  
  URG : 긴급 데이터  
  ACK : 받은 통신에 대한 응답  
  PSH : 세그먼트를 어플리케이션층으로 전달  
  RST : 통신 강제 해제  
  SYN : 통신 시작 요청  
  FIN : 통신 종료 요청  
  특히, 상대방과 서로 확인해가며 통신하는 것은 핸드셰이크 (HandShake)라고 한다. 이 때 통신을 시작할 때 주고 받은 3번의 통신을 3-way 핸드셰이크, 통신을 종료할 때 주고받는 4번의 통신을 4-WAY 핸드셰이크라고 한다.
   1. 3-way 핸드셰이크 (통신 개시)  
      - A : SYN=1 을 B에게 보낸다.  
      - B : SYN=1, ACK=1 을 A에게 보낸다.  
      - A : ACK=1 을 B에게 보낸다.  
   2. 4-way 핸드셰이크  
      - A : FIN=1 을 B에게 보낸다.  
      - B : ACK=1 을 A에게 보낸다. (이와 동시에 서버는 application에 close()를 요청한다.)  
      - B : FIN=1, ACK=1 을 A에게 보낸다.  
      - A : ACK=1 을 B에게 보낸다.  






4. 쿠키와 세션
HTTP 프로토콜은 Stateless 프로토콜이다. 즉 한번의 통신 요청과 응답으로 통신이 완료되면 통신 정보를 기억하지 않는다. 따라서 우리는 쿠키와 세션을 통해 사용자 정보를 기억해서 통신에 이용한다.
   1. 쿠키  
    - 클라이언트에 저장한다.
    - 만료 날짜 정보를 저장해 해당 날짜에 데이터가 만료된다.
    - 비교적 빠르다.
    - 주 사용처 : 자동로그인, 장바구니, 팝업다시보지않기
    - 프로세서 : 첫 요청 후 받은 응답과 함께 쿠키 정보 저장 후 재 요청시 쿠키 정보를 함께 보낸다.

   2. 세션  
    - 서버에 저장한다.
    - 브라우저 종료시 삭제된다.
    - 서버에서 처리하므로 비교적 느리다.
    - 주 사용처 : 로그인 유지
    - 프로세스 : 클라이언트의 요청에 따라 응답할 때 세션ID를 만들어 함께 클라이언트에 쿠키와 함께 저장한다. 동일 클라이언트가 요청할때 세션ID도 함께 서버로 넘어오고 이를 통해 정보 유지한다.


5. Web Socket


## 6. 운영체제