---
title: 운영체제10 - 물리 메모리 크기의 극복
date: "2019-09-22"
layout: post
draft: false
path: "/posts/OS/physicalmemory"
category: "OS"
tags:
  - "OS"
description: "물리 메모리 크기의 극복 : 메커니즘과 정책"
---

> 운영체제를 공부하기 위해 *운영체제 아주 쉬운 세 가지 이야기* 라는 책을 읽고 공부한 내용을 정리합니다.  
> 잘못되거나 부족한 부분이 있으면 언제든 댓글로 가르침 부탁드립니다.


### 목차
1. Swap 공간
2. 페이지 폴트 핸들러 매커니즘
3. 페이지 교체 정책 (Page Replacement Policy)
  
## 1. Swap 공간
### 1.1 더 큰 공간의 필요성
멀티프로그래밍 시스템이 개발되면서 물리 메모리 공간에 모든 프로세스의 페이지를 저장할 수 없게 되었다. 따라서 더 큰 저장 공간이 필요해졌고, 이는 곧 운영체제가 프로세스들에게 더 큰 가상 메모리 공간이 있다는 환상을 줄 수 있게 되는 것이다. 현재 시스템에서는 하드 디스크 드라이브가 이 역할을 담당하며 이 용도의 공간을 *스왑 공간 Swap Space* 라고 한다.

### 1.2 Present Bit
물리 메모리 공간에 모든 페이지 정보를 저장할 수 있다면 가상주소를 통해 물리 주소를 참조하는 과정은 아래 2가지이다.
1) TLB 참조 -> TLB 히트
2) TLB 참조 -> TLB 미스 -> 페이지 테이블에서 페이지 주소 조회 - 메모리 조회 - 페이지 TLB 탑재 -> 명령어 재실행 -> TLB 히트
  
하지만 물리 메모리 공간에 가상주소와 매핑되는 공간이 없다면, 이를 깨닫고 디스크에서 찾아야 한다. 이를 나타내기 위해서 *Present Bit* 라는 비트가 있다. Present Bit가 0이면 물리 메모리에 해당 페이지 없고 디스크에 존재하는 것을 의미한다. 이때 물리 메모리에 존재하지 않는 페이지에 접근하는 행위를 *페이지 폴트(Page-Fault)* 라고 표현한다. 페이지 폴트가 발생하면, 운영체제로 제어권이 넘어가고 페이지 폴트 핸들러(Page-Fault Handler)가 실행된다.  
  
* TLB 미스가 발생하는 경우 중, 버그 등으로 인하여 유효하지 않은 페이지 접근 요청이 있을 수도 있다. 이 경우 운영체제는 트랩 핸들러를 통해 처리한다.

  
## 2 페이지 폴트 핸들러 매커니즘
1) 스왑 공간 상의 페이지 위치도 페이지 테이블에 저장하기 때문에, 페이지 테이블에서 페이지 디스크 주소를 찾는다.
2) 디스크에서 페이지 정보를 조회한다.
3) 스왑 공간상의 페이지를 물리 메모리에 탑재시키고, 해당 물리 메모리 위치를 페이지 테이블에 갱신한다. 혹시 물리 메모리 상에 더 이상 공간이 없다면, 페이지 교체 정책을 이용해 기존 페이지를 페이지 아웃(Page-Out) 한다.
4) 페이지 폴트를 발생시킨 명령어를 재실행시킨다.

* 단, 디스크 I/O 과정 동안 운영체제는 다른 프로세스를 실행시킨다. 디스크 I/O 과정은 시간이 오래 걸리기 때문이다. 


## 3. 페이지 교체 정책 (Page Replacement Policy)
### 3.1 교체 정책이란?
스왑 공간에 있던 페이지를 물리 메모리에 갱신하려할 때, 이미 물리 메모리에 여유 공간이 없다면 기존 페이지를 아웃시켜 공간을 확보해야 한다. 이때 페이지 아웃 기준 정책을 *교체 정책(Replacement Policy)*이라고 한다.  
교체 정책의 목표는 캐시 미스, 즉 디스크로부터 페이지를 가져오려는 횟수를 최소로 만드는 것이다.

### 3.2 최적 교체 정책 (The Optimal Replacement Policy)
최적 교체 정책은 당연하게도 가장 나중에 접근될 페이지를 교체하는 것이다. 하지만 이는 가장 나중에 접근될 것을 예측할 수 있어야 하는데 이는 불가능 하다. 따라서 최적 교체 정책과 비교했을 때 가장 비슷한 성능을 보이는 교체 정책이 최선의 교체 정책이 될 것이다.

### 3.3 간단한 정책
1. FIFO : 먼저 들어왔던 페이지를 먼저 내보낸다. 최적 교체 정책 대비 성능이 매우 안좋다.
2. 무작위 선택 : 여전히 성능이 안 좋지만 평균적으로 FIFO보다 좋은 성능을 보인다.

### 3.4 LRU (Least Recently Used)
*지역성의 원칙*에 따라, 어떤 프로그램이 최근 어떤 페이지에 접근했다면 가까운 미래에 그 페이지를 다시 접근하게 될 확률이 높다는 특징을 이용하여 가장 오래 전에 참조되었던 페이지를 교체하는 정책이다. 단점은 순환형 워크로드에서는 성능이 좋지 않으며, 페이지가 증가할수록 페이지들의 참조된 시간 정보를 검색해야 하므로 고비용 연산이 필요하다.

### 3.5 LRU 정책 근사
LRU 정책의 고비용 연산 단점을 해결하기 위해 근사하는 정책도 존재한다. 각 페이지마다 use bit를 놓고 페이지가 참조될 때마다 하드웨어에 의해서 bit를 1로 바꾼다. 그리고 하드웨어는 절대 0으로 비트를 바꾸지 않는다. (운영체제가 이를 활용)
  
운영체제는 페이지를 순서대로 하나씩 방문하여 이 bit가 1인지 체크한다. 1이라면 최근에 참조되었다는 뜻이므로 비트를 0으로 변경하고 다음 페이지로 넘어가며 bit가 0인 페이지를 찾는다. 이 정책의 경우 LRU보다 성능이 좋진 않지만 과거 이력을 이용하지 않는 정책보다는 좋은 성능을 보인다.

