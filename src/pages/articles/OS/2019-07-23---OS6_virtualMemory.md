---
title: 운영체제6 - 가상메모리 개요
date: "2019-07-23"
layout: post
draft: false
path: "/posts/OS/virtualmemory"
category: "OS"
tags:
  - "OS"
description: "메모리 가상화에 대한 개요"
---

> 운영체제를 공부하기 위해 *운영체제 아주 쉬운 세 가지 이야기* 라는 책을 읽고 공부한 내용을 정리합니다.  
> 잘못되거나 부족한 부분이 있으면 언제든 댓글로 가르침 부탁드립니다.


### 목차
1. 메모리 가상화 필요성 대두
2. 하드웨어기반 주소변환 (베이스와 바운드)
3. 동적 재배치를 위한 OS의 역할
  
  
## 1. 가상메모리 필요성 대두
1. 컴퓨터는 고가의 장비였기 때문에 최대한 쉬는 시간없이 작동시킬 필요가 있었다. 그렇게 멀티프로그래밍 시대가 도래했고 여러 프로세스들을 실행 대기 상태로 두고 시분할로 CPU를 최대한 효율적으로 이용했다. 이때 메모리를 어떻게 프로세스마다 갈아 끼운다면 너무 느리기 때문에 메모리에 그대로 유지하는 방법을 선택하게 된다. 그와 동시 메모리 *보호* 가 중요한 문제로 대두되었다.
2. 메모리를 보호하기 위해 등장한 것이 *주소 공간* 이다. 메모리상에 프로세스마다 다른 주소 공간을 할당받고, 그 안에서 데이터의 특성에 따라 코드, 스택, 힙으로 나눠 데이터를 저장했다.
3. 그리고 OS가 이렇게 프로세스에게 주소 공간을 할당하는 것을 *메모리 가상화* 라고 한다. 프로세스가 1001번지라는 가상 주소에 저장하면 OS가 이 가상 주소를 실제 물리 주소와 매핑시켜 실제 메모리 주소에 저장하는 것이다.
  


## 2. 하드웨어기반 주소변환 (베이스와 바운드)
하드웨어는 명령어 탑재, 저장 등의 가상 주소를 정보가 실제 존재하는 물리 주소로 변환한다. 이때 *베이스 바운드* 라는 아이디어를 이용하여, 프로세스 모르게 메모리를 다른 위치에 배치하는 *동적 재배치* 가 가능하게 된다.   
    
베이스와 바운드는 CPU에 존재하는 레지스터로서, 주소 변환에 도움을 주는 MMU(Memory Management Unit)으로 불리기도 한다. 프로그램 시작 시, 운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정하고 베이스 레지스터를 그 주소로 지정하고 물리 주소는 아래와 같은 방법으로 변환된다.  
  
`physical address = virtual address + base`
그리고 바운드는 가상 주소가 적합한 범위 내에 있는지 확인하기 위해 사용된다.

* 동적 재배치의 단점 : 내부 단편화  
프로세스에게 할당된 주소공간이 모두 사용되지 않으면 내부적으로 메모리가 낭비된다. 이를 *내부 단편화* 라고 한다. 
내부 단편화란 구체적으로, 실행하고자 하는 프로세스가 필요로 하는 데이터공간보다 사용되는(차지하는) 메모리가 큰 경우를 의미한다.
이를 해결하기 위해서는 base-and-bound를 일반화하는 세그멘테이션이 필요하다.(다음장)
  
  

## 3. 동적 재배치를 위한 OS의 역할
1. 프로세스가 생성될 때 메모리가 저장될 공간을 찾아야 한다.
2. 프로세스 종료시, 사용되던 메모리를 회수해야 한다.
3. 문맥 교환마다 베이스와 바운드를 저장하고 복원해야 한다. (PCB에)
4. 예외 상황에 예외 핸들러를 호출해야 한다.