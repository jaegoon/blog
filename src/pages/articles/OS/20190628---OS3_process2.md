---
title: 운영체제3 - CPU 가상화 구현 - 제한적 직접 실행
date: "2019-06-28"
layout: post
draft: false
path: "/posts/OS/process2"
category: "OS"
tags:
  - "OS"
description: "CPU 가상화를 구현하기 위해 제한적 직접 실행에 대해 알아보자."
---

> 운영체제를 공부하기 위해 *운영체제 아주 쉬운 세 가지 이야기* 라는 책을 읽고 공부한 내용을 정리합니다.  
> 잘못되거나 부족한 부분이 있으면 언제든 댓글로 가르침 부탁드립니다.


### 목차
1. CPU 가상화 구현
2. 문제1 : 제한된 연산
3. 문제2 : 프로세스간 전환
4. 부팅부터 타이머 인터럽트를 통한 프로세스 전환까지의 과정
  
## 1. CPU 가상화 구현
CPU 가상화를 구현하기 위해서 Time sharing 방식을 이용한다. 프로세스들이 일정한 시간마다 CPU를 나눠쓰는 방식이다.  
이러한 Time sharing 방식을 빠르고 효율적으로 진행시키기 위해 운영체제 개발자들은 *제한적 직접 실행(Limited Direct Execution)* 이라는 기법을 개발했다. 이에 대해 자세히 알아보자.

먼저 *직접실행* 은 간단하다. 단순히 CPU가 프로세스를 실행한다는 것을 의미한다. 하지만 여기서 2가지 문제가 발생한다.  
1. 프로세스가 특수한 종류의 연산을 수행하길 원한다면 어떻게 할 것인가?
2. 어떤 프로세스를 다음에 실행시킬 것인가?



## 2. 문제1 : 제한된 연산
### 2.1 사용자모드와 커널모드
프로세스가 아무 파일에 접근하고, 메모리를 수정한다면 심각한 오류가 발생할 것이다. 따라서 OS는 모드를 2가지로 나눴다.
1. 사용자 모드(user mode)
2. 커널 모드(kernel mode)  
  
사용자 모드에서는 실행할 수 있는 코드가 제한되도록 하고 커널모드에서 중요한 코드를 실행하도록 하는 것이다.  
  
그렇다면 사용자가 특권 명령어를 실행하고 싶다면 어떻게 해야할까?  
이를 해결하기 위해 OS는 *시스템콜* 을 제공한다. 시스템콜을 실행하기 위해서는 `trap`이라는 특수 명령어를 실행해야 한다. 이 명령어를 실행하면, 권한을 커널모드로 상향시킨다. 그리고 프로세스가 커널모드에서 처리해야할 작업을 마치면 `return-from-trap` 명령어를 호출에 다시 사용자 모드로 권한을 하향시킨다.

### 2.2 trap과 interrupt
우리는 이전에 프로세스의 상태에 대한 그림에서 `running` 에서 `ready` 상태가 되는 것은 `interrupt`로 인해 발생한다고 그렸다. 여기서 `interrupt`의 의미를 살펴보면, `interrupt`는 CPU의 정상 진행을 방해한다는 의미로, CPU의 진행을 멈추게 하는 역할을 한다. 이러한 `interrupt`는 크게 2가지로 나뉜다. 오류, 에러등으로 인해 발생하는 내부 인터럽트와 타이머 인터럽트(일정 시간의 간격마다 지속적으로 인터럽트를 발생시키는 것) 혹은 I/O 에 의해 발생하는 외부 인터럽트이다.  
`trap`과 매우 비슷한 의미로 보이지만 다소 차이점이 있다. `interrupt`는 하드웨어에 의해서 발생하고, `trap`은 소프트웨어에 의해 발생한다는 점이다.



## 3. 문제2 : 프로세스간 전환
이제 2번째 문제에 대해 살펴보자. 프로세스를 어떤 기준으로 전환할 것인가.  
2가지 방식이 있다.
1. 협조 방식(cooperative) : 시스템콜 기다리기  
말그대로 진행중인 프로세스가 스스로 시스템콜을 보내, 운영체제가 다시 CPU의 제어권을 갖게 하는 것이다. 하지만 이 방식이 제대로 작동하려면, 프로세스를 신뢰할 수 있어야 한다는 전제가 필요하다.  

2. 비협조 방식 : 운영체제가 전권을 행사  
위에서 언급한 `Timer interrupt`를 이용해 일정 시간마다 `interrupt`를 발생시켜 운영체제가 CPU의 제어권을 얻는 방식이다. `interrupt`가 발생하면 현재 수행중인 프로세스는 중단되고 미리 구성된 운영체제의 인터럽트 핸들러가 실행된다. 이 시점에 운영체제는 CPU 제어권을 얻게되는 것이다.



## 4. 부팅 ~ 타이머 인터럽트를 통한 프로세스 전환까지의 과정
> (부팅중)  
> 1. 운영체제 : 트랩테이블 초기화, 인터럽트 타이머 시작시키기
> 2. 하드웨어 : 타이머 시작   
  
> (부팅완료)  
> 3. 사용자모드 : 프로세스 A 실행  
> 4. 하드웨어 : `Timer interrupt` 발생, 프로세스 A 레지스터를 커널 스택에 저장, 커널모드 이동, 트랩핸들러 분기  
> 5. 운영체제 : `Trap`처리, 프로세스 B로 전환, `return-from-trap` 실행  
> 6. 하드웨어 : B의 커널스택을 B의 레지스터로 저장, 사용자모드로 이동  
> 7. 사용자모드 : 프로세스 B 실행  